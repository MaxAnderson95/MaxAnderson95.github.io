---
import BaseLayout from "../../layouts/BaseLayout.astro";
import Navbar from "../../components/Navbar.astro";
import WorkTimelineCard from "../../components/WorkTimelineCard";
import Footer from "../../components/Footer";
import { workHistory } from "../../data/work-history";
---

<BaseLayout title="Work History — Max Anderson" description="Professional work history and career timeline for Max Anderson.">
  <Navbar active="work-history" />

  <main id="main-content" tabindex="-1" class="relative z-10 w-full max-w-[1100px] mx-auto px-6 md:px-10 pt-28 pb-20">
    {/* Header */}
    <div class="reveal mb-16" style="animation-delay: 0.15s;">
      <h1 class="font-display font-extrabold text-[clamp(2rem,5vw,3rem)] tracking-tight leading-tight text-text">
        Work History
      </h1>
      <p class="mt-3 text-text-secondary text-lg font-light max-w-xl">
        A timeline of my professional career and the roles that shaped my expertise.
      </p>
    </div>

    {/* Timeline */}
    <section aria-label="Work history timeline">
      <div class="timeline" role="list">
        {/* Vertical line */}
        <div class="timeline-line" aria-hidden="true"></div>

        {workHistory.map((entry, i) => (
          <div
            class="timeline-entry"
            role="listitem"
            style={`--entry-index: ${i};`}
            data-index={i}
          >
            <WorkTimelineCard
              company={entry.company}
              companyUrl={entry.companyUrl}
              location={entry.location}
              positions={entry.positions}
              index={i}
            />
          </div>
        ))}
      </div>
    </section>
  </main>

  <Footer />
</BaseLayout>

<script>
  const OVERLAP_FRACTION = 1 / 3;
  const SAME_SIDE_GAP = 24;
  const MOBILE_BREAKPOINT = 768;

  function layoutTimeline() {
    const container = document.querySelector(".timeline") as HTMLElement | null;
    if (!container) return;

    const entries = Array.from(
      container.querySelectorAll<HTMLElement>(".timeline-entry")
    );
    if (!entries.length) return;

    // On mobile, reset any inline positioning — CSS handles static flow
    if (window.innerWidth < MOBILE_BREAKPOINT) {
      container.style.height = "";
      entries.forEach((el) => {
        el.style.top = "";
        el.removeAttribute("data-side");
      });
      return;
    }

    let leftBottom = 0;
    let rightBottom = 0;
    let prevTop = 0;
    let prevHeight = 0;
    let prevSide: "left" | "right" = "right"; // first card will prefer left
    let maxBottom = 0;

    entries.forEach((entry, i) => {
      const height = entry.offsetHeight;
      const desiredTop = i === 0 ? 0 : prevTop + prevHeight * OVERLAP_FRACTION;

      // Where each side can start without same-side overlap
      const leftStart = Math.max(leftBottom, desiredTop);
      const rightStart = Math.max(rightBottom, desiredTop);

      // Prefer opposite side; fall back to shorter side if it's much better
      const preferred: "left" | "right" =
        prevSide === "left" ? "right" : "left";
      const preferredStart =
        preferred === "left" ? leftStart : rightStart;
      const otherStart =
        preferred === "left" ? rightStart : leftStart;

      let side: "left" | "right";
      let top: number;

      if (preferredStart <= otherStart + 50) {
        side = preferred;
        top = preferredStart;
      } else {
        side = preferred === "left" ? "right" : "left";
        top = otherStart;
      }

      entry.style.top = `${top}px`;
      entry.dataset.side = side;

      if (side === "left") {
        leftBottom = top + height + SAME_SIDE_GAP;
      } else {
        rightBottom = top + height + SAME_SIDE_GAP;
      }

      maxBottom = Math.max(maxBottom, top + height);
      prevTop = top;
      prevHeight = height;
      prevSide = side;
    });

    container.style.height = `${maxBottom}px`;
  }

  function initTimelineReveal() {
    const entries = document.querySelectorAll<HTMLElement>(".timeline-entry");
    if (!entries.length) return;

    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
      entries.forEach((el) => el.classList.add("is-visible"));
      return;
    }

    const observer = new IntersectionObserver(
      (items) => {
        items.forEach((item) => {
          if (item.isIntersecting) {
            item.target.classList.add("is-visible");
            observer.unobserve(item.target);
          }
        });
      },
      { threshold: 0.1, rootMargin: "0px 0px -40px 0px" }
    );

    entries.forEach((el) => observer.observe(el));
  }

  function init() {
    layoutTimeline();
    initTimelineReveal();
  }

  // Debounced resize re-layout
  let resizeTimer: ReturnType<typeof setTimeout>;
  window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
      layoutTimeline();
    }, 150);
  });

  // Re-layout after fonts load (heights may change)
  document.fonts.ready.then(() => layoutTimeline());

  init();
  document.addEventListener("astro:page-load", init);
</script>
